/* eslint-disable */
/// <reference path="./custom.d.ts" />
// tslint:disable
{{>licenseInfo}}

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

{{#servers}}
{{#if @first}}
const BASE_PATH = "{{{url}}}".replace(/\/+$/, "");
{{/if}}
{{/servers}}
{{^servers}}
const BASE_PATH = "";
{{/servers}}

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
	csv: ",",
	ssv: " ",
	tsv: "\t",
	pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
	(url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
	url: string;
	options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
	protected configuration: Configuration;

	constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
		if (configuration) {
			this.configuration = configuration;
			this.basePath = configuration.basePath || this.basePath;
		}
	}
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
	name: "RequiredError"
	constructor(public field: string, msg?: string) {
		super(msg);
	}
}

{{#models}}
{{#if isEnum}}
{{>modelEnum}}
{{else}}
{{>modelGeneric}}
{{/if}}
{{/models}}
{{#groups}}
/**
 * {{className name}}Api - fetch parameter creator{{#if description}}
 * {{&description}}{{/if}}
 * @export
 */
export const {{className name}}ApiFetchParamCreator = function (configuration?: Configuration) {
	return {
	{{#operations}}
		/**
		 * {{&description}}
		 {{#if summary}}
		 * @summary {{&summary}}
		 {{/if}}
		 {{#allParams}}
		 * @param {{safe '{'}}{{&nativeType}}{{safe '}'}} {{^required}}[{{/required}}{{identifier name}}{{^required}}]{{/required}} {{description}}
		 {{/allParams}}
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		{{identifier name}}({{#allParams}}{{identifier name}}: {{{nativeType}}}{{#if nullable}} | null{{/if}}{{^required}} | undefined{{/required}}, {{/allParams}}options: any = {}): FetchArgs {
	{{#allParams}}
	{{#if required}}
	{{#unless nullable}}
			// verify required parameter '{{identifier name}}' is not null or undefined
			if ({{identifier name}} === null || {{identifier name}} === undefined) {
				throw new RequiredError('{{identifier name}}','Required parameter {{identifier name}} was null or undefined when calling {{identifier ../name}}.');
			}
	{{else}}
			// verify required parameter '{{identifier name}}' is not undefined
			if ({{identifier name}} === undefined) {
				throw new RequiredError('{{identifier name}}','Required parameter {{identifier name}} was undefined when calling {{identifier ../name}}.');
			}
	{{/unless}}
	{{/if}}
	{{/allParams}}
			const localVarPath = `{{{../path}}}{{{path}}}`{{#pathParams}}
				.replace('{{safe '{'}}{{{name}}}{{safe '}'}}', encodeURIComponent(String({{identifier name}}))){{/pathParams}};
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: '{{httpMethod}}' }, options);
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;
	{{#if formParams}}
			const localVarFormParams = new URLSearchParams();
	{{/if}}

	{{#securityRequirements}}
			// authentication {{scheme.name}} required
			{{#if scheme.isApiKey}}
			{{#if scheme.isInHeader}}
			if (configuration && configuration.apiKey) {
				const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("{{identifier scheme.name}}")
					: configuration.apiKey;
				localVarHeaderParameter["{{identifier scheme.name}}"] = localVarApiKeyValue;
			}
			{{/if}}
			{{#if scheme.isInQuery}}
			if (configuration && configuration.apiKey) {
				const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("{{identifier scheme.name}}")
					: configuration.apiKey;
				localVarQueryParameter["{{identifier scheme.name}}"] = localVarApiKeyValue;
			}
			{{/if}}
			{{/if}}
			{{#if scheme.isBasic}}
			// http basic authentication required
			if (configuration && (configuration.username || configuration.password)) {
				localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
			}
			{{/if}}
			{{#if scheme.isOAuth}}
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("{{scheme.name}}", [{{#scopes}}"{{{name}}}"{{#unless @last}}, {{/unless}}{{/scopes}}])
					: configuration.accessToken;
				localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
			}
			{{/if}}

	{{/securityRequirements}}
	{{#queryParams}}
			{{#if isListContainer}}
			if ({{identifier name}}) {
			{{#if isCollectionFormatMulti}}
				localVarQueryParameter['{{name}}'] = {{identifier name}};
			{{else}}
				localVarQueryParameter['{{name}}'] = {{identifier name}}.join(COLLECTION_FORMATS["{{collectionFormat}}"]);
			{{/if}}
			}
			{{else}}
			if ({{identifier name}} !== undefined) {
				{{#if isDateTime}}
				localVarQueryParameter['{{name}}'] = {{identifier name}}.toISOString();
				{{else if isDate}}
				localVarQueryParameter['{{name}}'] = {{identifier name}}.toISOString().replace(/T.*/, "");
				{{else}}
				localVarQueryParameter['{{name}}'] = {{identifier name}};
				{{/if}}
			}
			{{/if}}

	{{/queryParams}}
	{{#headerParams}}
			{{#if isListContainer}}
			if ({{identifier name}}) {
				localVarHeaderParameter['{{name}}'] = {{identifier name}}.join(COLLECTION_FORMATS["{{collectionFormat}}"]));
			}
			{{else}}
			if ({{identifier name}} !== undefined && {{identifier name}} !== null) {
				localVarHeaderParameter['{{name}}'] = String({{identifier name}});
			}
			{{/if}}

	{{/headerParams}}
	{{#formParams}}
			{{#if isListContainer}}
			if ({{identifier name}}) {
			{{#if isCollectionFormatMulti}}
				{{identifier name}}.forEach((element) => {
					localVarFormParams.append('{{name}}', element as any);
				})
			{{else}}
					localVarFormParams.set('{{name}}', {{identifier name}}.join(COLLECTION_FORMATS["{{collectionFormat}}"]));
			{{/if}}
			}
			{{else}}
			if ({{identifier name}} !== undefined) {
				localVarFormParams.set('{{name}}', {{identifier name}} as any);
			}
			{{/if}}

	{{/formParams}}
	{{#if formParams}}
			localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

	{{/if}}
	{{#bodyParam}}
			{{^../consumes}}
			localVarHeaderParameter['Content-Type'] = 'application/json';
			{{/../consumes}}
			{{#../consumes}}
			{{#if @first}}
			localVarHeaderParameter['Content-Type'] = '{{{mediaType}}}';
			{{/if}}
			{{/../consumes}}

	{{/bodyParam}}
			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
	{{#if formParams}}
			localVarRequestOptions.body = localVarFormParams.toString();
	{{/if}}
	{{#bodyParam}}
			const needsSerialization = (<any>"{{nativeType}}" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
			localVarRequestOptions.body =  needsSerialization ? JSON.stringify({{identifier name}} || {}) : ({{identifier name}} || "");
	{{/bodyParam}}

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	{{/operations}}
	}
};

/**
 * {{className name}}Api - functional programming interface{{#if description}}
 * {{{description}}}{{/if}}
 * @export
 */
export const {{className name}}ApiFp = function(configuration?: Configuration) {
	return {
	{{#operations}}
		/**
		 * {{&description}}
		 {{#if summary}}
		 * @summary {{&summary}}
		 {{/if}}
		 {{#allParams}}
		 * @param {{safe '{'}}{{&nativeType}}{{safe '}'}} {{^required}}[{{/required}}{{identifier name}}{{^required}}]{{/required}} {{description}}
		 {{/allParams}}
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		{{identifier name}}({{#allParams}}{{identifier name}}: {{{nativeType}}}{{#if nullable}} | null{{/if}}{{^required}} | undefined{{/required}}, {{/allParams}}options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{{#if returnNativeType.wireType}}{{{returnNativeType}}}{{else}}Response{{/if}}> {
			const localVarFetchArgs = {{className ../name}}ApiFetchParamCreator(configuration).{{identifier name}}({{#allParams}}{{identifier name}}, {{/allParams}}options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response{{#if returnNativeType.wireType}}.json(){{/if}};
					} else {
						throw response;
					}
				});
			};
		},
	{{/operations}}
	}
};

/**
 * {{className name}}Api - factory interface{{#if description}}
 * {{&description}}{{/if}}
 * @export
 */
export const {{className name}}ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
	{{#operations}}
		/**
		 * {{&description}}
		 {{#if summary}}
		 * @summary {{&summary}}
		 {{/if}}
		 {{#allParams}}
		 * @param {{safe '{'}}{{&nativeType}}{{safe '}'}} {{^required}}[{{/required}}{{identifier name}}{{^required}}]{{/required}} {{description}}
		 {{/allParams}}
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		{{identifier name}}({{#allParams}}{{identifier name}}: {{{nativeType}}}{{#if nullable}} | null{{/if}}{{^required}} | undefined{{/required}}, {{/allParams}}options?: any) {
			return {{className ../name}}ApiFp(configuration).{{identifier name}}({{#allParams}}{{identifier name}}, {{/allParams}}options)(fetch, basePath);
		},
	{{/operations}}
	};
};

{{#withInterfaces}}
/**
 * {{className name}}Api - interface{{#if description}}
 * {{&description}}{{/if}}
 * @export
 * @interface {{className name}}Api
 */
export interface {{className name}}ApiInterface {
{{#operations}}
	/**
	 * {{&description}}
	 {{#summary}}
	 * @summary {{&summary}}
	 {{/summary}}
	 {{#allParams}}
	 * @param {{safe '{'}}{{&nativeType}}{{safe '}'}} {{^required}}[{{/required}}{{identifier name}}{{^required}}]{{/required}} {{description}}
	 {{/allParams}}
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof {{className ../name}}ApiInterface
	 */
	{{identifier name}}({{#allParams}}{{identifier name}}: {{{nativeType}}}{{#if nullable}} | null{{/if}}{{^required}} | undefined{{/required}}, {{/allParams}}options?: any): Promise<{{#if returnNativeType}}{{{returnNativeType}}}{{else}}{}{{/if}}>;

{{/operations}}
}

{{/withInterfaces}}
/**
 * {{className name}}Api - object-oriented interface{{#if description}}
 * {{{description}}}{{/if}}
 * @export
 * @class {{className name}}Api
 * @extends {BaseAPI}
 */
{{#if withInterfaces}}
export class {{className name}}Api extends BaseAPI implements {{className name}}ApiInterface {
{{else}}
export class {{className name}}Api extends BaseAPI {
{{/if}}
	{{#operations}}
	/**
	 * {{&description}}
	 {{#if summary}}
	 * @summary {{&summary}}
	 {{/if}}
	 {{#allParams}}
	 * @param {{safe '{'}}{{&nativeType}}{{safe '}'}} {{^required}}[{{/required}}{{identifier name}}{{^required}}]{{/required}} {{description}}
	 {{/allParams}}
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof {{className ../name}}Api
	 */
	public {{identifier name}}({{#allParams}}{{identifier name}}: {{{nativeType}}}{{#if nullable}} | null{{/if}}{{^required}} | undefined{{/required}}, {{/allParams}}options?: any) {
		return {{className ../name}}ApiFp(this.configuration).{{identifier name}}({{#allParams}}{{identifier name}}, {{/allParams}}options)(this.fetch, this.basePath);
	}

	{{/operations}}
}
{{/groups}}
