package {{apiPackage}};

{{#imports}}import {{.}};
{{/imports}}

import javax.ws.rs.*;
import javax.ws.rs.core.CacheControl;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.ResponseBuilder;
import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;

import io.swagger.annotations.*;
import io.swagger.jaxrs.PATCH;
import java.io.InputStream;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.apache.cxf.jaxrs.ext.multipart.Attachment;
import org.apache.cxf.jaxrs.ext.multipart.Multipart;

import java.util.Map;
import java.util.List;

@Path("{{{path}}}")
// @RequestScoped // This annotation is commented out, which makes the service a Singleton. There seems to be a bug that causes the securityContext to be lost if the service is RequestScoped

@Api(description = "the {{{name}}} API")
{{#if consumes}}
@Consumes({ {{#consumes}}"{{{.}}}"{{#unless @last}}, {{/unless}}{{/consumes}} })
{{/if}}
{{#if produces}}
@Produces({ {{#produces}}"{{{.}}}"{{#unless @last}}, {{/unless}}{{/produces}} })
{{/if}}
{{>generatedAnnotation}}

@SuppressWarnings("all")
public class {{className name}}Api  {

  @Inject {{className name}}ApiService delegate;

  @SuppressWarnings("all")
  private static final Log log = LogFactory.getLog({{className name}}Api.class);

{{#operations}}
{{^vendorExtensions.x-implementation-provided}}
{{>nestedModels}}
	@{{httpMethod}}
	{{#if authMethods}}
	{{#if @root.authenticatedOperationAnnotation}}
	{{@root.authenticatedOperationAnnotation}}
	{{/if}}
	{{/if}}
	{{#isDeprecated}}
	@Deprecated
	{{/isDeprecated}}
	{{#if path}}
	@Path("{{{path}}}")
	{{/if}}
	{{#if consumes}}
	@Consumes({ {{#consumes}}"{{{mediaType}}}"{{#hasMore}}, {{/hasMore}}{{/consumes}} })
	{{/if}}
	{{#if produces}}
	@Produces({ {{#produces}}"{{{mediaType}}}"{{#hasMore}}, {{/hasMore}}{{/produces}} })
	{{/if}}
	@ApiOperation(value = "{{{summary}}}", notes = "{{{notes}}}"{{#if returnNativeType}}, response = {{{returnNativeType.literalType}}}.class{{/if}}{{#returnContainer}}, responseContainer = "{{{returnContainer}}}"{{/returnContainer}}{{#if authMethods}}, authorizations = {
		{{#authMethods}}@Authorization(value = "{{name}}"{{#isOAuth}}, scopes = {
			{{#scopes}}@AuthorizationScope(scope = "{{scope}}", description = "{{description}}"){{#unless @last}},
			{{/unless}}{{/scopes}}
		}{{/isOAuth}}){{#unless @last}},
		{{/unless}}{{/authMethods}}
	}{{/if}}, tags={ {{#tags}}"{{.}}"{{#unless @last}}, {{/unless}}{{/tags}} })
	@ApiResponses(value = { {{#responses}}
		@ApiResponse(code = {{{code}}}, message = "{{{description}}}", response = {{#if nativeType}}{{{nativeType.literalType}}}{{else}}Void{{/if}}.class{{#containerType}}, responseContainer = "{{{containerType}}}"{{/containerType}}){{#hasMore}},{{/hasMore}}{{/responses}}
	})
	public Response {{name}}({{#allParams}}{{>queryParams}}{{>pathParams}}{{>headerParams}}{{>bodyParams}}{{>formParams}}{{#hasMore}}, {{/hasMore}}{{/allParams}}) {
		{{#responses}}{{#isDefault}}final ResponseBuilder response = Response.status({{code}}).cacheControl(CacheControl.valueOf("{{{vendorExtensions.x-cache-control}}}{{^vendorExtensions.x-cache-control}}no-cache, no-store, must-revalidate, private{{/vendorExtensions.x-cache-control}}"));{{/isDefault}}{{/responses}}
		{{#isDeprecated}}log.error("Deprecated API called: {{name}}");{{/isDeprecated}}
		try {
			{{#@root.useBeanValidation}}
			{{#allParams}}
			{{#if vendorExtensions.x-validation}}
			javax.validation.ValidatorFactory factory = javax.validation.Validation.buildDefaultValidatorFactory();
			javax.validation.Validator validator = factory.getValidator();
			java.util.Set<javax.validation.ConstraintViolation<{{{nativeType}}}>> validations = validator.validate({{identifier name}});
			if (!validations.isEmpty()) {
				throw new {{{className @root/name}}}ApiService.{{{className ../name}}}400Exception(validations);
			}
			
			{{/if}}
			{{/allParams}}
			{{/@root.useBeanValidation}}
			{{#defaultResponse}}
			{{#if nativeType}}{{{nativeType}}} entity = {{/if}}delegate.{{identifier ../name}}({{#../allParams}}{{#if isFile}}{{identifier name}}InputStream, {{identifier name}}Detail{{else}}{{identifier name}}{{/if}}{{#hasMore}}, {{/hasMore}}{{/../allParams}}{{#unless nativeType}}, response{{/unless}});
			{{#if nativeType}}
			response.entity(entity);
			{{/if}}
			return response.build();
			{{/defaultResponse}}
		{{#responses}}
		{{^isDefault}}
		} catch ({{{className @root/name}}}ApiService.{{{className ../name}}}{{{code}}}Exception e) {
			response.status({{code}});
			{{^vendorExtensions.x-java-is-response-void}}
			response.entity(e.getEntity());
			{{/vendorExtensions.x-java-is-response-void}}
			return response.build();
		{{/isDefault}}
		{{/responses}}
		} finally {
		
		}
	}

{{/vendorExtensions.x-implementation-provided}}
{{/operations}}
}
